<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TrueSize-MapLibre-Demp</title>
  <link href="https://unpkg.com/maplibre-gl@3.5.2/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    html, body { height: 100vh; width: 100vw; margin: 0; }
    #map { height: 100vh; width: 100vw; }
    .info { position:absolute; top:12px; left:12px; z-index:10; background:rgba(255,255,255,.92);
            padding:10px 12px; border-radius:10px; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;
            box-shadow:0 6px 20px rgba(0,0,0,.15); max-width:min(680px,84vw); }
    .info h1 { margin:0 0 6px; font-size:16px; }
    .pill { display:inline-block; padding:2px 8px; border-radius:999px; background:#f1f5f9; margin-right:6px; font-size:12px; }
    .legend { font-size:12px; color:#334155; margin-top:6px; }
    .err { color:#b91c1c; font-weight:600; }
    .ctrl { margin-top:8px; display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .ctrl input[type="range"]{ width:240px; }
    .file { font-weight:600; }
    .muted { color:#64748b; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="info">
    <h1>TrueSize-MapLibre-Demo <a href="https://truesize.world/" target="_blank" style="font-size:12px; margin-left:8px; text-decoration:none; color:#2563eb;">访问 TrueSize.world ↗</a></h1>
    <div><span class="pill">拖动：只平移（保持北向）</span><span class="pill">旋转：下方滑块</span><span class="pill">Esc 取消拖动</span></div>
    <div class="ctrl">
      <label>旋转 <span id="rotv">0°</span></label>
      <input id="rot" type="range" min="-180" max="180" step="1" value="0" />
      <button id="rotReset" type="button">重置</button>
      <span class="muted">可行区间：<b id="rotRange">—</b></span>
    </div>
    <div class="legend" id="legend">准备就绪。</div>
  </div>

  <script src="https://unpkg.com/maplibre-gl@3.5.2/dist/maplibre-gl.js"></script>
  <script>
  // ========== 0) 读取 URL 参数 ==========
  function getTargetFile() {
    const p = new URLSearchParams(location.search).get('file');
    const f = p ? decodeURIComponent(p) : 'Greenland.json';
    window.__targetFile = f;
    return f;
  }
  async function loadFeatureStrict() {
    const fileName = getTargetFile();
    const res = await fetch(fileName, { cache: 'no-store' });
    if (!res.ok) throw new Error('未能读取同目录下的 ' + fileName);
    const data = await res.json();
    let geom = null;
    if (data.type === 'Feature') geom = data.geometry;
    else if (data.type === 'FeatureCollection') {
      const f = (data.features || []).find(f => f && f.geometry && (f.geometry.type === 'Polygon' || f.geometry.type === 'MultiPolygon'));
      if (!f) throw new Error('GeoJSON 内没有 Polygon/MultiPolygon');
      geom = f.geometry;
    } else if (data.type === 'Polygon' || data.type === 'MultiPolygon') geom = data;
    else throw new Error('不支持的 GeoJSON 类型：' + data.type);
    if (!geom || !(geom.type === 'Polygon' || geom.type === 'MultiPolygon')) throw new Error('几何必须是 Polygon 或 MultiPolygon');
    return (geom.type === 'Polygon') ? [geom.coordinates] : geom.coordinates;
  }

  // ========== 1) MapLibre ==========
  const map = new maplibregl.Map({
    container: 'map',
    style: 'https://demotiles.maplibre.org/style.json',
    center: [105, 35],
    zoom: 2,
    hash: false,
    dragRotate: false
  });
  map.addControl(new maplibregl.NavigationControl({ visualizePitch: false }));

  // ========== 2) 数学工具 ==========
  const d2r = Math.PI/180, r2d = 180/Math.PI;
  function sph2cart(lon, lat) { const φ=lat*d2r, λ=lon*d2r; const cφ=Math.cos(φ); return [cφ*Math.cos(λ), cφ*Math.sin(λ), Math.sin(φ)]; }
  function cart2sph([x,y,z]) { const lon=Math.atan2(y,x)*r2d; const hyp=Math.hypot(x,y); const lat=Math.atan2(z,hyp)*r2d; return [((lon+540)%360)-180, Math.max(Math.min(lat,89.9999),-89.9999)]; }
  function vdot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
  function vcross(a,b){return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}
  function vadd(a,b){return [a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
  function vscale(a,s){return [a[0]*s,a[1]*s,a[2]*s];}
  function vnorm(a){const n=Math.hypot(a[0],a[1],a[2]); return n?[a[0]/n,a[1]/n,a[2]/n]:[0,0,0];}
  function qMultiply(a,b){return [a[0]*b[0]-a[1]*b[1]-a[2]*b[2]-a[3]*b[3], a[0]*b[1]+a[1]*b[0]+a[2]*b[3]-a[3]*b[2], a[0]*b[2]-a[1]*b[3]+a[2]*b[0]+a[3]*b[1], a[0]*b[3]+a[1]*b[2]-a[2]*b[1]+a[3]*b[0]]; }
  function qFromAxisAngle(axis,angle){ const u=vnorm(axis), s=Math.sin(angle/2); return [Math.cos(angle/2), u[0]*s, u[1]*s, u[2]*s]; }
  function qFromUnitVectors(a,b){ const w=1+vdot(a,b); if(w<1e-8){ let axis=Math.abs(a[0])>Math.abs(a[2])?[-a[1],a[0],0]:[0,-a[2],a[1]]; const u=vnorm(axis); return [0,u[0],u[1],u[2]];} const c=vcross(a,b); const q=[w,c[0],c[1],c[2]]; const n=Math.hypot(q[0],q[1],q[2],q[3]); return [q[0]/n,q[1]/n,q[2]/n,q[3]/n]; }
  function qRotateVec(q,v){ const s=q[0], u=[q[1],q[2],q[3]]; const uv=vcross(u,v), uuv=vcross(u,uv); return vadd(vadd(v, vscale(uv, 2*s)), vscale(uuv,2)); }
  function northTangent(lon, lat){ const φ=lat*d2r, λ=lon*d2r; return [-Math.sin(φ)*Math.cos(λ), -Math.sin(φ)*Math.sin(λ), Math.cos(φ)]; }
  function slerp(a, b, t) { let d=Math.max(-1,Math.min(1,vdot(a,b))); const w=Math.acos(d); if(w<1e-8) return a.slice();
    const s=Math.sin(w); const s1=Math.sin((1-t)*w)/s, s2=Math.sin(t*w)/s; return vnorm([a[0]*s1+b[0]*s2,a[1]*s1+b[1]*s2,a[2]*s1+b[2]*s2]); }

  function toVectors(multiLL){ return multiLL.map(p=>p.map(r=>r.map(([lon,lat])=>sph2cart(lon,lat)))); }
  function toLngLat(multiV){ return multiV.map(p=>p.map(r=>r.map(v=>cart2sph(v)))); }

  // unwrap / recenter
  function unwrapRingLL(ring){
    if(!ring || ring.length===0) return ring;
    const out=[]; let prev=ring[0][0]; let off=0;
    for(let i=0;i<ring.length;i++){
      let lon=ring[i][0], lat=ring[i][1]; let lonAdj=lon+off;
      if(i>0){ const d=lonAdj-prev; if(d>180){ off-=360; lonAdj=lon+off; } else if(d<-180){ off+=360; lonAdj=lon+off; } }
      out.push([lonAdj,lat]); prev=lonAdj;
    }
    const [lon0,lat0]=out[0]; const [lonn,latn]=out[out.length-1];
    if(Math.abs(lon0-lonn)>1e-9||Math.abs(lat0-latn)>1e-9) out.push([lon0,lat0]);
    return out;
  }
  function unwrapMultiLL(coords){ return coords.map(poly=>poly.map(ring=>unwrapRingLL(ring))); }
  function shiftMultiLL(coords,dx){ if(!dx) return coords; return coords.map(p=>p.map(r=>r.map(([x,y])=>[x+dx,y]))); }
  function meanLon(coords){ let s=0,c=0; for(const p of coords) for(const r of p) for(const [x] of r){ s+=x; c++; } return c? s/c : 0; }
  function meanLat(coords){ let s=0,c=0; for(const p of coords) for(const r of p) for(const [,y] of r){ s+=y; c++; } return c? s/c : 0; }
  function recenterToRefLng(coords, refLng){ const m=meanLon(coords); const k=Math.round((refLng-m)/360); return shiftMultiLL(coords,360*k); }

  // Mercator 极限裁剪 + 遮罩
  const MAX_MERC_LAT = 85.0511287798066;
  const Y_MAX = Math.log(Math.tan(Math.PI/4 + (MAX_MERC_LAT*d2r)/2));
  function latToMercY(lat){ const φ = Math.max(Math.min(lat, 89.9999), -89.9999)*d2r; return Math.log(Math.tan(Math.PI/4 + φ/2)); }
  function mercYToLat(y){ return (2*Math.atan(Math.exp(y)) - Math.PI/2)*r2d; }
  function clipHalfByY(pts, yBound, keepBelow){
    const out=[]; if(!pts||pts.length===0) return out;
    for(let i=0;i<pts.length;i++){
      const a=pts[i], b=pts[(i+1)%pts.length];
      const ain = keepBelow ? (a.y<=yBound) : (a.y>=yBound);
      const bin = keepBelow ? (b.y<=yBound) : (b.y>=yBound);
      const intersect = ()=>{ const t=(yBound - a.y)/((b.y - a.y) || 1e-12); return { x:a.x + t*(b.x - a.x), y:yBound }; };
      if(ain && bin){ out.push(b); }
      else if(ain && !bin){ out.push(intersect()); }
      else if(!ain && bin){ out.push(intersect()); out.push(b); }
    }
    return out;
  }
  function clipRingMercatorCap(ring){
    if(!ring||ring.length<2) return [];
    let pts = ring.map(([lon,lat])=>({ x: lon, y: latToMercY(lat) }));
    pts = clipHalfByY(pts,  Y_MAX, true);
    pts = clipHalfByY(pts, -Y_MAX, false);
    if(!pts||pts.length<2) return [];
    let out = pts.map(p=>[p.x, mercYToLat(p.y)]);
    const a=out[0], b=out[out.length-1];
    if(Math.abs(a[0]-b[0])>1e-9 || Math.abs(a[1]-b[1])>1e-9) out.push([a[0],a[1]]);
    return out;
  }
  function clipByMercatorCaps(coords){
    const polys=[];
    for(const poly of coords){
      const rings=[];
      for(const ring of poly){
        const r=clipRingMercatorCap(ring);
        if(r && r.length>=4) rings.push(r);
      }
      if(rings.length) polys.push(rings);
    }
    return polys;
  }
  function addPolarMask(map){
    const CAP=MAX_MERC_LAT;
    const fc={ type:'FeatureCollection', features:[
      { type:'Feature', properties:{which:'north'}, geometry:{ type:'Polygon', coordinates:[[[-180,CAP],[180,CAP],[180,90],[-180,90],[-180,CAP]]] } },
      { type:'Feature', properties:{which:'south'}, geometry:{ type:'Polygon', coordinates:[[[-180,-90],[180,-90],[180,-CAP],[-180,-CAP],[-180,-90]]] } },
    ]};
    if(!map.getSource('polar')){
      map.addSource('polar',{ type:'geojson', data: fc });
      map.addLayer({ id:'polar-mask', type:'fill', source:'polar', paint:{ 'fill-color':'#0ea5e9', 'fill-opacity':0.12 } });
      map.addLayer({ id:'polar-edge', type:'line', source:'polar', paint:{ 'line-color':'#2563eb', 'line-width':2, 'line-dasharray':[2,2] } });
    }
  }

  function computeBounds(coords){
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const p of coords) for(const r of p) for(const [x,y] of r){
      if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y;
    }
    return [[minX,minY],[maxX,maxY]];
  }

  const legendEl = document.getElementById('legend');
  const rotRangeEl = document.getElementById('rotRange');
  function updateLegend(lat, rotDeg) {
    const rad=Math.abs(lat)*Math.PI/180; const k=1/Math.cos(rad);
    const f=window.__targetFile||'Greenland.json';
    legendEl.innerHTML = `数据文件 <span class="file">${f}</span> · 中心纬度 φ ≈ ${lat.toFixed(2)}° · Mercator 比例 k ≈ ${k.toFixed(2)} · 旋转 ${rotDeg.toFixed(0)}°`;
  }

  // ========== 3) 交互与限制（提速 + 防越界） ==========
  (async function init(){
    try{
      const base = await loadFeatureStrict();
      const baseCenter = { lng: meanLon(base), lat: meanLat(base) };
      const baseCenterVec = sph2cart(baseCenter.lng, baseCenter.lat);
      const baseNorth = northTangent(baseCenter.lng, baseCenter.lat);

      let dlon = 0, dlat = 0;     // 目标中心 = baseCenter + (dlon, dlat)
      let rotDeg = 0;             // 额外自旋（滑块）
      let lastValidCenter = { lng: baseCenter.lng, lat: baseCenter.lat };
      let lastValidRot = 0;

      const CENTER_LAT_LIMIT = 80.0;   // 中心纬度硬阈值
      const LIMIT_LAT = MAX_MERC_LAT;  // Mercator 可视上限
      const ROT_MARGIN = 1.5;          // 安全余量加大，进一步稳住边界

      const origVectors = toVectors(base);

      // 预采样（带参数）
      function densifyVectors(vecMulti, sampleDeg=0.8, maxSteps=6) {
        return vecMulti.map(poly => poly.map(ring => {
          const out = [];
          for (let i=0; i<ring.length-1; i++) {
            const A = ring[i], B = ring[i+1];
            const omega = Math.acos(Math.max(-1, Math.min(1, vdot(A, B))));
            const steps = Math.min(maxSteps, Math.max(0, Math.ceil(omega / (sampleDeg * d2r))));
            out.push(A);
            for (let k=1; k<=steps; k++) out.push(slerp(A, B, k/(steps+1)));
          }
          out.push(ring[ring.length-1]);
          return out;
        }));
      }
      // 渲染用（快） & 判定用（密）
      const denseVectorsFast = densifyVectors(origVectors, 0.8, 6);
      const denseVectorsSafe = densifyVectors(origVectors, 0.25, 24);

      // 构造旋转总四元数
      function buildTotalQuat(lng, lat, rot){
        const tgtVec = sph2cart(lng, lat);
        const qMove = qFromUnitVectors(baseCenterVec, tgtVec);
        const northMoved = qRotateVec(qMove, baseNorth);
        const bUnit = vnorm(tgtVec);
        function projPerp(v){ return vadd(v, vscale(bUnit, -vdot(v,bUnit))); }
        const v1 = vnorm(projPerp(northMoved));
        const v2 = vnorm(projPerp(northTangent(lng, lat)));
        const cross = vcross(v1, v2);
        const sinT = vdot(cross, bUnit);
        const cosT = vdot(v1, v2);
        const qFix = qFromAxisAngle(bUnit, Math.atan2(sinT, cosT));
        const qSpin = qFromAxisAngle(bUnit, (rot||0) * d2r);
        return qMultiply(qSpin, qMultiply(qFix, qMove));
      }

      // 用某套点计算纬度范围
      function latExtentsWithVectors(vecs, qTotal){
        let minLat =  90, maxLat = -90;
        for (const poly of vecs) for (const ring of poly) for (const P of ring) {
          const Pv = qRotateVec(qTotal, P);
          const latd = cart2sph(Pv)[1];
          if (latd < minLat) minLat = latd;
          if (latd > maxLat) maxLat = latd;
        }
        return {minLat, maxLat};
      }

      function withinCaps(lng, lat, rot){
        const qTotal = buildTotalQuat(lng, lat, rot);
        const ext = latExtentsWithVectors(denseVectorsSafe, qTotal); // 判定用：更密
        return (ext.maxLat <= (LIMIT_LAT - ROT_MARGIN) &&
                ext.minLat >= -(LIMIT_LAT - ROT_MARGIN));
      }

      function rotBoundsForCenter(lng, lat, anchor){
        let L=anchor, H=180, hi=anchor;
        for(let i=0;i<20;i++){
          const mid=(L+H)/2;
          if(withinCaps(lng,lat,mid)){ hi=mid; L=mid; } else { H=mid; }
        }
        L=-180; H=anchor; let lo=anchor;
        for(let i=0;i<20;i++){
          const mid=(L+H)/2;
          if(withinCaps(lng,lat,mid)){ lo=mid; H=mid; } else { L=mid; }
        }
        return [lo, hi];
      }

      // 合帧
      let rafPending = false;
      function scheduleRender(){ if(rafPending) return; rafPending = true; requestAnimationFrame(()=>{ rafPending=false; render(); }); }

      // 区间节流
      let lastRotBoundsTS = 0;
      function updateRotRangeThrottled(lng, lat) {
        const now = performance.now();
        if (now - lastRotBoundsTS > 120) {
          const [lo,hi] = rotBoundsForCenter(lng, lat, rotDeg);
          lastRotBoundsTS = now;
          rotRangeEl.textContent = `${Math.round(lo)}° ~ ${Math.round(hi)}°`;
        }
      }

      function render(){
        let tgt = { lng: baseCenter.lng + dlon,
                    lat: Math.max(Math.min(baseCenter.lat + dlat, CENTER_LAT_LIMIT), -CENTER_LAT_LIMIT) };

        const qTotal = buildTotalQuat(tgt.lng, tgt.lat, rotDeg);

        // 应用到“渲染用（快）”点集
        const rotated = denseVectorsFast.map(p=>p.map(r=>r.map(v=>qRotateVec(qTotal, v))));
        let coords = toLngLat(rotated);
        coords = unwrapMultiLL(coords);
        coords = clipByMercatorCaps(coords);
        coords = recenterToRefLng(coords, map.getCenter().lng);

        const data = { type:'Feature', geometry:{ type:'MultiPolygon', coordinates: coords } };
        if (map.getSource('country')) map.getSource('country').setData(data);
        else map.addSource('country', { type:'geojson', data });
        if (!map.getLayer('country-fill')){
          map.addLayer({ id:'country-fill', type:'fill', source:'country', paint:{ 'fill-color':'#8b5cf6', 'fill-opacity':0.28 } });
          map.addLayer({ id:'country-line', type:'line', source:'country', paint:{ 'line-color':'#7c3aed', 'line-width':2 } });
          map.fitBounds(computeBounds(coords), { padding: 60, duration: 0 });
        }

        updateRotRangeThrottled(tgt.lng, tgt.lat);
        updateLegend(tgt.lat, rotDeg);
      }

      map.on('load', () => {
        addPolarMask(map);
        scheduleRender();

        // 拖拽：贴边水平滑动
        let dragging=false, dragOffset={dlon:0,dlat:0};
        function startDrag(e){
          e.preventDefault(); dragging=true; map.dragPan.disable(); map.getCanvas().style.cursor='grabbing';
          const curCenter = { lng: baseCenter.lng + dlon, lat: baseCenter.lat + dlat };
          lastValidCenter = { ...curCenter };
          dragOffset = { dlon: e.lngLat.lng - curCenter.lng, dlat: e.lngLat.lat - curCenter.lat };
          map.on('mousemove', onMove); map.once('mouseup', onUp);
        }
        function onMove(e){
          if(!dragging) return;
          const candidate = { lng: e.lngLat.lng - dragOffset.dlon, lat: e.lngLat.lat - dragOffset.dlat };
          if (Math.abs(candidate.lat) <= CENTER_LAT_LIMIT && withinCaps(candidate.lng, candidate.lat, rotDeg)) {
            dlon = candidate.lng - baseCenter.lng;
            dlat = candidate.lat - baseCenter.lat;
            lastValidCenter = { ...candidate };
            scheduleRender();
          } else {
            const edgeLat = (candidate.lat===0 ? (lastValidCenter.lat>=0?1:-1) : Math.sign(candidate.lat)) * CENTER_LAT_LIMIT;
            const gliding = { lng: candidate.lng, lat: edgeLat };
            if (withinCaps(gliding.lng, gliding.lat, rotDeg)) {
              dlon = gliding.lng - baseCenter.lng;
              dlat = edgeLat - baseCenter.lat;
              lastValidCenter = { ...gliding };
              scheduleRender();
            }
          }
        }
        function onUp(){ if(!dragging) return; dragging=false; map.dragPan.enable(); map.getCanvas().style.cursor=''; map.off('mousemove', onMove); }
        map.on('mouseenter','country-fill',()=> map.getCanvas().style.cursor='grab');
        map.on('mouseleave','country-fill',()=> { if(!dragging) map.getCanvas().style.cursor=''; });
        map.on('mousedown','country-fill', startDrag);
        map.on('mousedown','country-line', startDrag);

        window.addEventListener('keydown',(ev)=>{ if(ev.key==='Escape' && dragging){ dragging=false; map.dragPan.enable(); map.getCanvas().style.cursor=''; map.off('mousemove', onMove); } });
      });

      // 旋转滑块：强制夹取 + 二分回退 + 数值回写
      const rotEl = document.getElementById('rot');
      const rotV = document.getElementById('rotv');
      const rotReset = document.getElementById('rotReset');

      function applyRotationSafely(want){
        const lng = baseCenter.lng + dlon;
        const lat = Math.max(Math.min(baseCenter.lat + dlat, CENTER_LAT_LIMIT), -CENTER_LAT_LIMIT);

        // 先用“保守区间”强制夹取
        const [minOk, maxOk] = rotBoundsForCenter(lng, lat, rotDeg);
        let lo=minOk, hi=maxOk;
        let applied = Math.max(Math.min(want, hi), lo);

        // 若仍不通过，做二分回退（最多 20 次）
        if (!withinCaps(lng, lat, applied)) {
          for (let i=0;i<20;i++){
            const mid = (applied > rotDeg) ? (rotDeg + (applied-rotDeg)/2) : (rotDeg - (rotDeg-applied)/2);
            if (withinCaps(lng, lat, mid)) { applied = mid; break; }
            // 退回到更接近 rotDeg 的一半
            applied = (applied + rotDeg)/2;
          }
          // 再保险：最终仍不通过就用上一次有效角
          if (!withinCaps(lng, lat, applied)) applied = lastValidRot;
        }

        rotDeg = applied; lastValidRot = rotDeg;
        rotEl.value = String(Math.round(rotDeg));
        rotV.textContent = `${Math.round(rotDeg)}°`;
        scheduleRender();
      }

      rotEl.addEventListener('input', ()=> {
        const want = Number(rotEl.value)||0;
        applyRotationSafely(want);
      });

      rotReset.addEventListener('click', ()=>{ applyRotationSafely(0); });

      map.on('moveend', scheduleRender);
    }catch(err){
      const f = window.__targetFile || 'Greenland.json';
      document.getElementById('legend').innerHTML =
        `<span class="err">加载失败：</span>${err.message}。请确认 <b>${f}</b> 位于此 HTML 的同目录下，且通过 <b>本地 HTTP 服务</b> 访问（避免 file:// 的浏览器安全限制），其几何为 <b>Polygon/MultiPolygon</b>。`;
      console.error(err);
    }
  })();
  </script>
</body>
</html>
